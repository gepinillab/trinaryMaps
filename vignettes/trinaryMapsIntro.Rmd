---
title: "Trinary Maps Vignette"
author: "Cory Merow and Gonzalo E. Pinilla-Buitrago"
date: "2014-08-31"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Background
Continuous model predictions are compared against binary data for evaluation in a variety of application; I'm thinking about Species Distribution Models (SDMs) but the following could be probably be used for any application. To evaluate the continuous predictions of the model - in the SDM case the 'suitability' scores - one must choose a threshold value of suitability above which the model predicts a species presence and below which the model predicts absence. Coming up with a reasonable threshold is difficult for SDMs, particularly when presence-backround data are involved. Use of the AUC statistic is meant to avoid the issues of choosing a particular threshold and evaluate model performance over all possible thresholds. Even still, in SDM applications, there is still often a need for generating a binary map from continuous predictions, which means picking a threshold. 

The specific problem of choosing a threshold when using presence-background data for SDMs is that the background is 'contaminated'  - it contains (unknown) presences that biases binary classification statistics. One common threshold choice is based on maximizing the sum of sensitivity and specificity (i.e., the Youden threshold), but this penalizes a model for incorrectly predicting background points as presence locations, when in fact they may be presences.The contribution of 'trinaryMaps' is to put some useful bounds on what reasonable values of the threshold might be. If we can't determine an optimal threshold, we can at least identify upper and lower limits so we know we have it surrounded.

The approach to identifying these limits is heuristic and not based on any formal theory; rather it is based on analyzing the ROC curve and identifying limits beyond which model predictions aren't likely to be very useful in the application of SDMs. For example, why would any care about the discrimination of an SDM based on a threshold that gets only 7% of presences correct? This implies there should be a upper limit on a useful threshold (higher threshold implies fewer predicted presences). Similarly, why would anyone want a model that predicts that only 4% of the background is an absence? If your model were that nondiscriminating, why even build a model when you could just use the modeling domain as a range esimate? So this suggests there is a useful lower limit (lower threshold implies more predicted presences). How can we objectively find these upper and lower limits? Answering that is the contribution of trinaryMaps.

# Using Trinary Maps
Building trinary maps involves the same inputs as one would use for binary classification and in this package is specifically structured for use with SDMs:
1. Model prediction (spatRaster)
2. Occurrences coordinates (data.frame)
3. Background coordinates (data.frame)

# Basic Workflow
The `trinaryMapWorkflow()` function is the main entry point for using the package. It performs the following steps:
1. Calculates upper and lower threshold bounds
2. Creates a trinary map based on these bounds
3. Calculates range sizes associated with the generated trinary map
Plots the ROC curve with upper and lower threshold bounds

Here's an example of how to use the trinaryMapWorkflow function:

```{r}
library(trinaryMaps)
library(maxnet)
library(predicts)
library(terra)

# Load example data
occurence <- system.file("/ex/bradypus.csv", package = "predicts")
occ <- read.csv(occurence)[, -1]
f <- system.file("ex/bio.tif", package="predicts")
envs <- terra::rast(f)

# Prepare data for modeling
data <- terra::values(envs) |> as.data.frame()
data$ID <- 1:(terra::nrow(envs) * terra::ncol(envs))
occs.p <- terra::extract(envs, occ, cells = TRUE)
data$p <- rep(0, terra::ncell(envs))
data$p[occs.p$cell] <- 1
data$x <- terra::xFromCell(envs, 1:terra::ncell(envs))
data$y <- terra::yFromCell(envs, 1:terra::ncell(envs))
data <- na.omit(data)

# Build and predict model
mod <- maxnet(data$p, data[, 1:9])
p.vals <- predict(mod, terra::values(envs), type = "cloglog")
suitability <- rep(NA, terra::ncell(envs))
suitability[data$ID] <- p.vals
r <- envs[[1]]
names(r) <- "suitability"
terra::values(r) <- suitability

# Run trinaryMapWorkflow
tr <- trinaryMapWorkflow(pres = data[data$p == 1, c("x", "y")], 
                         background = data[data$p == 0, c("x", "y")], 
                         rModel = r)
```

```{r}
# Plot trinary map
plot(tr$trinary.rasters)
```

```{r}
# Area
trinaryRangeSize(tr$trinary.rasters)
```

```{r}
trinaryROCPlot(tr$threshs$plotThings, trinaryDF = tr$threshs$trinaryDF)
```

There are also functions that allow you to interact with each of the 5 steps above rather than calling them all at once, in case customization is needed.